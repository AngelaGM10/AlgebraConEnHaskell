\chapter{Programación funcional con Haskell}\label{sec:progfunHas}

En este capítulo se hace una breve introducción a la programación funcional en
Haskell suficiente para entender su aplicación en los siguientes
capítulos. Para una introducción más amplia se pueden consultar los apuntes de
la asignatura de Informática de 1º del Grado en Matemáticas
(\cite{Alonso-15b}), la web de "¡Aprende haskell por el bien de todos!" (\cite{aprendehaskell}) y la web oficial de Haskell (\cite{haskell}) . Las funciones predefinidas en Haskell que vamos a utilizar en los siguientes capítulos pertenecen, entre otras, a la librería \href{http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html}{\texttt{Data.List}} de Haskell.\\

Con la programación puramente funcional no ejecutamos órdenes, sino más bien, definimos como son las cosas. Al definir una función se le asocia un tipo que determina el comportamiento de la función, esto permite al compilador razonar acerca de el comportamiento, y nos permite ver si una función es correcta o no antes de ejecutarla. De esta forma podemos construir funciones más complejas uniendo funciones simples.\\

Haskell es un lenguaje tipado. Esto significa que todos los ojetos tienen asociado un tipo. También las funciones, por lo que se pueden detectar errores en tiempo de compilación.\\

Vamos a explicar brevemente los conceptos importantes para entender mejor la programación funcional en Haskell:

\begin{itemize}

\item \textbf{Funciones de orden superior}

Las funciones de Haskell pueden tomar funciones como parámetros y devolver funciones como resultado. Una función que hace ambas cosas o alguna de ellas se llama función de orden superior. Es decir, si una función toma como argumento a otra función o devuelve una función como resultado se dice que es una función de orden superior. Por ejemplo, las funciones \texttt{foldr}, \texttt{filter} y \texttt{zipWith} son funciones de orden superior, todas ellas toman a otra función como argumento.\\

\item \textbf{Tipos}

Cada función en Haskell tiene asociada un tipo. Al programar la función no es necesario especificar el tipo, pues Haskell lo puede inferir. Es conveniente especificar el tipo sobre el que queremos utilizar la función, para que al crear nuevas funciones no se produzcan problemas de tipos.\\

Un tipo en Haskell es como un conjunto de elementos que tienen algo en común. Por ejemplo el grupo de los números enteros \mathbb{Z} se representa por el tipo \texttt{Integer}. Los tipos básicos de Haskell son: \texttt{Integer}, \texttt{Int}, \texttt{Char}, \texttt{Bool}, \texttt{Double} y \texttt{Float}.\\

\item  \textbf{Clases de tipos}

Las clases de tipos son una especie de interfaz que define algún tipo de comportamiento. Si un tipo es miembro de una clase de tipos, significa que ese tipo soporta e implementa el comportamiento que define la clase de tipos. Cada clase tiene unas propiedades que se aplican a los elementos que se utilizan estando en dicha clase. Por ejemplo: \texttt{Eq}, \texttt{Show} y \texttt{Ord} son algunas de las clases básicas.\\

Podemos crear nuevas clases de tipos escribiendo \texttt{class Ring a where}, la nueva clase de tipo que hemos definido se llama \texttt{Ring}. La \texttt{a} es la variable de tipo, esta representará el tipo sobre el que se trabajará en la clase \texttt{Ring}. Debajo del \texttt{where} definimos varias funciones. Solo hay que especificar las declaraciones de tipo de las funciones.\\

\item \textbf{Restricciones de clases de tipos}

Para concretar sobre qué propiedades queremos trabajar se puede restringir una clase dentro de otra. Por ejemplo, la función \texttt{group} tiene el siguiente tipo:
\begin{center}
\texttt{group :: Eq a =>  [a] ->  [[a]]}
\end{center}
La función \texttt{group} recibe una lista de elementos de \texttt{a}. Se exige que \texttt{a} sea un tipo con igualdad, es decir, que pertenezca a la clase \texttt{Eq}. Sin embargo la función \texttt{elem} con el siguiente tipo:
\begin{center}
\texttt{elem :: (Foldable t, Eq a) =>  a ->  t a -> Bool}
\end{center}
Esta restringida a dos clases, de esta forma la función \texttt{ elem } tiene las propiedades de ambas clases.\\ 

\item \textbf{Instancias}

Un tipo puede ser una instancia de una clase si soporta el comportamiento de la clase. Por ejemplo:  El tipo \texttt{Int} es una instancia de la clase \texttt{Eq}, ya que la clase de tipos \texttt{Eq} define el comportamiento de elementos que se pueden equiparar, y los números enteros pueden equipararse.\\

También podemos utilizar instancias sobre las clases que hayamos creado. Al declarar una instancia, estamos declarando el tipo sobre el que la clase va a actuar bajo los atributos que se definan. Las funciones que se definan y estén restringidas a la nueva clase, verificará los atributos de esta clase.

\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "TFG"
%%% End:
